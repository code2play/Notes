# 协同过滤

## 相似度计算

相似度计算是协同过滤中核心的步骤，对于向量$\bold{a}$和$\bold{b}$可以用以下方法计算其相似度：

### 欧式距离

$$
sim = ||\bold{a}-\bold{b}||
$$

### 余弦相似度

$$
sim = \frac{\bold{a}\cdot \bold{b}}{||\bold{a}||\cdot||\bold{b}||}
$$

### 皮尔逊相关系数

$$
sim = \frac{cov(\bold{a}, \bold{b})}{\sigma_{\bold{a}}\sigma_{\bold{b}}} \\
cov(\bold{a}, \bold{b}) = E[(\bold{a}-\mu_{\bold{a}})(\bold{b}-\mu_{\bold{b}})]
$$

### Jaccard相似度

如果向量$\bold{a}, \bold{b}$的值只有0和1，可将其看作两个集和$A, B$
$$
sim = \frac{|A \cap B|}{|A \cup B|}
$$

## User-Based CF

对于用户$a$和用户$b$，可利用其对所有物品的评分向量计算两者喜好的相似度$sim(\bold{a}, \bold{b})$。

然后对于用户$a$没有评价过的物品$i$，通过如下方法预测$a$对$i$的评分：
$$
\bold{a}_i = \frac{\sum_{b \in U_i} sim(\bold{a}, \bold{b}) \cdot \bold{b}_i}{\sum_{b \in U_i} sim(\bold{a}, \bold{b})}
$$
其中$U_i$表示评价过物品$i$的用户集和，分母的作用是将数值归一化到原来的评分取值区间。

得到用户$a$对未评论物品的预测打分后，可将预测评分较高的物品推荐给该用户。

## Item-Based CF

对于物品$i$和物品$j$，可利用所有用户对其评分向量计算两者的相似度$sim(\bold{i}, \bold{j})$。

然后对于用户$a$没有评价过的物品$i$，通过如下方法预测$a$对$i$的评分：
$$
\bold{a}_i = \frac{\sum_{j \in I_a} \bold{a}_j \cdot sim(\bold{i}, \bold{j})}{\sum_{j \in I_a} sim(\bold{i}, \bold{j})}
$$
其中$I_a$表示用户$a$评价过的物品的集和，分母的作用同样是归一化。

为了简化计算，可只取$i \in I_{a, K}$，$I_{a, K}$表示用户$a$评价过的物品中，每个物品最相似的$K$个物品组成的集和。

同时Item-Based CF还可以在用户浏览物品时推荐相似的物品，也可以对推荐做出解释，比如向用户推荐了物品$i$时，可以认为该物品是根据$\bold{a}_j \cdot sim(\bold{i}, \bold{j})$值最大的物品$j$推荐的。

## User-Based与Item-Based的比较

从算法原理的角度看，User-Based的推荐结果着重于反映和用户兴趣相似的小群体的热点，而Item-Based的推荐结果着重于维系用户的历史趣。换句话说，User-Based的推荐更社会化，反映了用户所在的小型兴趣群体中物品的热门程度，而Item-Based的推荐更加个性化，反映了用户自己的兴趣传承。

同时，从技术上考虑，User-Based需要维护一个用户相似度的矩阵，而Item-Based需要维护一个物品相似度矩阵。从存储的角度说，如果用户数量远大于物品数量，那么维护用户兴趣相似度矩阵需要很大的空间，选用Item-Based更合适；同理，如果物品数量远大于用户数量或物品相似度变化很快（例如新闻网站），那么维护物品相似度矩阵代价较大，选用User-Based更合适。

- User-Based和Item-Based详细对比

|          |                          User-Based                          |                          Item-Based                          |
| :------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
|   性能   |                     适用于用户较少的场合                     |               适用于物品数明显小于用户数的场合               |
|   领域   |         适用于时效性强，用户个性化兴趣不太明显的领域         |                适用于用户个性化需求强烈的领域                |
|  实时性  |           用户有新行为不一定造成推荐结果的立即变化           |           用户有新行为一定会导致推荐结果的实时变化           |
|  冷启动  | 不能立即对新用户进行个性化推荐，因为用户相似度表是每隔一段时间离线计算的。新物品上线后一段时间就可以将其推荐给与喜欢该物品的用户相似的用户 | 新用户只要对一个物品产生行为，就可以给他推荐相关的物品。但新物品不会在更新物品相似度表前被推荐给用户 |
| 推荐理由 |                 很难提供令用户信服的推荐解释                 |      利用用户的历史行为给用户做推荐解释，比较能让人信服      |

## Model-Based CF

基于模型的协同过滤种类繁多，主要是通过机器学习的思想来解决推荐问题，比较常见的方法如下：

- 关联算法
- 聚类算法：如果基于用户聚类，则可以将用户按照一定距离度量方式分成不同的目标人群，将同样目标人群评分高的物品推荐给目标用户。基于物品聚类的话，则是将用户评分高物品的相似同类物品推荐给用户。 
- 分类算法/回归算法：直接用分类/回归算法预测评分。
- 矩阵分解：传统的SVD将矩阵分解为$U\Sigma V^T$的形式，然后预测得分为$u_i^T\Sigma v_j$，但是SVD的复杂度高，因此出现了一些改进算法，将矩阵$M_{m\times n}$分解为$P^T_{m\times k}Q_{k\times n}$，然后预测得分为$q_j^Tp_i$，矩阵$P$和$Q$是通过梯度下降的方法训练的。

- 神经网络
- 图模型
- 隐语义分析：利用TF-IDF、LSA、LDA等方法分析物品的内容特征。

## 评价指标

### 预测准确度

用RMSE或MAE计算预测评分的误差。

### 准确率/召回率

如果是TopN推荐，可以使用准确率和召回率来评价推荐结果。令$R(u)$是根据用户在训练集上的行为给用户作出的推荐列表，而$T(u)$是用户在测试集上的行为列表。那么，推荐结果的召回率和准确率定义为：
$$
Recall = \frac{\sum_{u\in U} |R(u) \cap T(u)|}{\sum_{u\in U}|T(u)|} \\
Precision = \frac{\sum_{u\in U} |R(u) \cap T(u)|}{\sum_{u\in U}|R(u)|}
$$

### 覆盖率

有些推荐系统希望每个物品都被推荐给用户，此时可以用覆盖率来评价推荐系统。
$$
Coverage = \frac{|\bigcup_{u\in U} R(u) |}{|I|}
$$
其中$\bigcup$是求并集，$I$是所有物品的集和。

此外也可以用信息熵和基尼指数来评价覆盖率。

### 多样性

有时希望推荐系统能够覆盖用户的多个兴趣，而不是用户的某个兴趣。多样性描述了推荐列表中的物品两两之间的不相似性，其定义如下：
$$
Diversity = 1-\frac{\sum_{i, j \in R(u), i\ne j} sim(\bold{i}, \bold{j})}{\frac{1}2 |R(u)|(|R(u)|-1)}
$$
推荐系统整体的多样性可以定义为每个用户的推荐列表多样性的平均值

### 其他

此外推荐系统的评价指标还有新颖性、惊喜度等，以及线上的用户满意度、用户活跃度变化、盈利等商业目标。

## 冷启动问题

冷启动问题（cold start）主要分3类：

- **用户冷启动**：用户冷启动主要解决如何给新用户做个性化推荐的问题。当新用户到来时， 我们没有他的行为数据，所以也无法根据他的历史行为预测其兴趣，从而无法借此给他 做个性化推荐。
- **物品冷启动**：物品冷启动主要解决如何将新的物品推荐给可能对它感兴趣的用户这一问题。
- **系统冷启动**：系统冷启动主要解决如何在一个新开发的网站上（还没有用户，也没有用 户行为，只有一些物品的信息）设计个性化推荐系统，从而在网站刚发布时就让用户体验到个性化推荐服务这一问题。

对于这3种不同的冷启动问题，有不同的解决方案。一般来说，可以参考如下解决方案：

- **提供非个性化的推荐**：非个性化推荐的最简单例子就是热门排行榜，我们可以给用户推荐热门排行榜，然后等到用户数据收集到一定的时候，再切换为个性化推荐。
- 利用用户注册时提供的年龄、性别等数据做粗粒度的个性化。
- 利用用户的社交网络账号登录（需要用户授权），导入用户在社交网站上的好友信息，然后给用户推荐其好友喜欢的物品。
- 要求用户在登录时对一些物品进行反馈，收集用户对这些物品的兴趣信息，然后给用户推荐那些和这些物品相似的物品。
- 对于新加入的物品，可以利用内容信息，将它们推荐给喜欢过和它们相似的物品的用户。
- 在系统冷启动时，可以引入专家的知识，通过一定的高效方式迅速建立起物品的相关度表。

## References

- 推荐系统实践
- 集体智慧编程
- 机器学习实战
- [协同过滤推荐算法总结](http://www.cnblogs.com/pinard/p/6349233.html)

