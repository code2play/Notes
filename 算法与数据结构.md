# 算法与数据结构

## 算法

### 排序

[https://blog.csdn.net/lutianfeiml/article/details/51958962](https://blog.csdn.net/lutianfeiml/article/details/51958962)

[https://www.cnblogs.com/RainyBear/p/5258483.html](https://www.cnblogs.com/RainyBear/p/5258483.html)

| 排序方法     | 平均情况        | 最好情况 | 最坏情况 | 辅助空间     | 稳定性 |
| ------------ | --------------- | -------- | -------- | ------------ | ------ |
| 冒泡排序     | O(n^2)          | O(n)     | O(n^2)   | O(1)         | 稳定   |
| 简单选择排序 | O(n^2)          | O(n^2)   | O(n^2)   | O(1)         | 稳定   |
| 直接插入排序 | O(n^2)          | O(n)     | O(n^2)   | O(1)         | 稳定   |
| 希尔排序     | O(nlogn)~O(n^2) | O(n^1.3) | O(n^2)   | O(1)         | 不稳定 |
| 堆排序       | O(nlogn)        | O(nlogn) | O(nlogn) | O(1)         | 不稳定 |
| 归并排序     | O(nlogn)        | O(nlogn) | O(nlogn) | O(n)         | 稳定   |
| 快速排序     | O(nlogn)        | O(nlogn) | O(n^2)   | O(logn)~O(n) | 不稳定 |

#### 冒泡

[成绩排序](https://www.nowcoder.com/practice/0383714a1bb749499050d2e0610418b1?tpId=40&tqId=21333&tPage=1&rp=1&ru=/ta/kaoyan&qru=/ta/kaoyan/question-ranking)

这个题需要稳定的排序算法，所以手撸冒泡

```c++
#include<bits/stdc++.h>
using namespace std;

struct stu{
    string name;
    int grade;
};

bool cmp2(stu s1, stu s2){
    return s1.grade>s2.grade;
}

bool cmp1(stu s1, stu s2){
    return s1.grade<s2.grade;
}

int main(){
    int n, how;
    stu s[10000];
    while(cin>>n>>how){
        for(int i=0;i<n;i++)
            cin>>s[i].name>>s[i].grade;
        for(int i=0;i<n;i++){
            for(int j=0;j<n-i-1;j++){
                if(how==0 && cmp1(s[j], s[j+1]))
                    swap(s[j], s[j+1]);
                else if(how==1 && cmp2(s[j], s[j+1]))
                    swap(s[j], s[j+1]);
            }
        }
        for(int i=0;i<n;i++)
            cout<<s[i].name<<' '<<s[i].grade<<endl;
    }
}

```

### 搜索 

#### BFS

[Meteor Shower](http://poj.org/problem?id=3669)

```c++
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
#include<queue>
using namespace std;

const int maxn = 405;
const int inf=9999999;
int m[maxn][maxn];
const int dir[][2]={1,0, -1,0, 0,1, 0,-1, 0,0};
struct node{int x,y,t;};

int bfs(){
    if(m[0][0]==0) return -1;
    else if(m[0][0]==-1) return 0;
    node a;
    a.x=a.y=a.t=0;
    queue<node>q;
    q.push(a);
    while( !q.empty() ){
        node b=q.front();
        q.pop();
        for(int i=0;i<4;i++ ){
            a.x=b.x+dir[i][0];
            a.y=b.y+dir[i][1];
            a.t=b.t+1;
            if(a.x<0||a.y<0||a.x>=maxn||a.y>=maxn) continue;
            if(m[a.x][a.y]==-1) return a.t;
            if(a.t>=m[a.x][a.y]) continue;
            m[a.x][a.y]=a.t;
            q.push(a);
        }
    }
    return -1;
}

int main(){
    int n;
    while(scanf("%d",&n)!=EOF){
        int x,y,t;
        memset(m,-1,sizeof(m));
        while(n--){
            scanf("%d%d%d",&x,&y,&t);
            for(int i=0;i<5;i++){
                int xx=x+dir[i][0];
                int yy=y+dir[i][1];
                if(xx<0||yy<0||xx>=maxn||yy>=maxn) continue;
                if(m[xx][yy]==-1) m[xx][yy]=t;
                else m[xx][yy]=min(m[xx][yy], t);
            }
        }
        printf("%d\n", bfs());
    }
    return 0;
}
```

[玛雅人的密码](https://www.nowcoder.com/practice/761fc1e2f03742c2aa929c19ba96dbb0?tpId=40&tqId=21343&tPage=1&rp=1&ru=/ta/kaoyan&qru=/ta/kaoyan/question-ranking)

```c++
#include<bits/stdc++.h>
using namespace std;

struct node{
    string x;
    int step;
};
queue<node> q;
set<string> s;
string a;
int n;

int main(){
    while(cin>>n){
        cin>>a;
        s.insert(a);
        node b;
        b.x=a; b.step=0;
        q.push(b);
        int cnt=0;
        bool flag=0;
        while(!q.empty()){
            b=q.front();
            q.pop();
            int f=b.x.find("2012");
            if(f>=0 && f<n){
                cout<<b.step<<endl;
                flag=1;
                break;
            }
            for(int i=0;i<n-1;i++){
                node c;
                c.x=b.x; c.step=b.step+1;
                swap(c.x[i], c.x[i+1]);
                if(s.find(c.x)==s.end()){
                    s.insert(c.x);
                    q.push(c);
                }
            }
        }
        if(!flag) cout<<"-1"<<endl;
    }
}
```

#### DFS

[Red and Black](http://poj.org/problem?id=1979)

```c++
#include<bits/stdc++.h>
using namespace std;

int W, H, sx, sy, ans;
int dir[4][2]={1,0, -1,0, 0,1, 0,-1};
char m[25][25];

bool check(int x, int y){
    if(x>=0 && x<H && y>=0 && y<W)
        return true;
    return false;
}

void dfs(int x, int y){
    ans++;
    m[x][y]='@';
    for(int i=0;i<4;i++){
        int xx=x+dir[i][0], yy=y+dir[i][1];
        if(check(xx, yy) && m[xx][yy]=='.')
            dfs(xx, yy);
    }
}

int main(){
    while(cin>>W>>H){
        if(W==0 || H==0) break;
        for(int i=0;i<H;i++){
            for(int j=0;j<W;j++){
                cin>>m[i][j];
                if(m[i][j]=='@'){
                    sx=i; sy=j;
                }
            }
        }

        ans=0;
        dfs(sx, sy);
        cout<<ans<<endl;
    }
}
```

[Curling 2.0](http://poj.org/problem?id=3009)

```c++
#include<bits/stdc++.h>
using namespace std;

int W, H, sx, sy, ans;
int dir[4][2]={1,0, -1,0, 0,1, 0,-1};
char m[25][25];

bool check(int x, int y){
    if(x>=0 && x<H && y>=0 && y<W)
        return true;
    return false;
}

void dfs(int x, int y, int step){
    if(step>10) return;
    for(int i=0;i<4;i++){
        int xx=x+dir[i][0], yy=y+dir[i][1];
        if(m[xx][yy]=='1') continue;
        while(1){
            if(!check(xx, yy)) break;
            if(m[xx][yy]=='3') {
                ans=min(ans, step+1);
                break;
            }
            if(m[xx][yy]=='1'){
                m[xx][yy]='0';
               dfs(xx-dir[i][0], yy-dir[i][1], step+1);
                m[xx][yy]='1';
                break;
            }
            xx+=dir[i][0];
            yy+=dir[i][1];
        }
    }
}

int main(){
    while(cin>>W>>H){
        if(W==0 || H==0) break;
        for(int i=0;i<H;i++){
            for(int j=0;j<W;j++){
                cin>>m[i][j];
                if(m[i][j]=='2'){sx=i; sy=j;}
            }
        }
        ans=11;
        dfs(sx, sy, 0);
        if(ans<=10) cout<<ans<<endl;
        else cout<<"-1"<<endl;
    }
}
```

[Hopscotch](http://poj.org/problem?id=3050)

```c++
#include<bits/stdc++.h>
using namespace std;

int grid[6][6],t;
const int dir[4][2]={1,0,-1,0,0,1,0,-1};
set<int> x;

void dfs(int a,int b,int depth)
{
    if(depth==5){
        x.insert(t);
        return;
    }
    for(int i=0;i<4;i++){
        int x,y;
        x=a+dir[i][0];
        y=b+dir[i][1];
        if(x<0 || x>=5 || y<0 || y>=5) continue;
        t=t*10+grid[x][y];
        dfs(x,y,depth+1);
        t-=grid[x][y];
        t/=10;
    }
}

int main()
{
    for(int i=0;i<5;i++)
        for(int j=0;j<5;j++)
            scanf("%d",&grid[i][j]);
    for(int i=0;i<5;i++){
        for(int j=0;j<5;j++){
            t=grid[i][j];
            dfs(i,j,0);
        }
    }
    printf("%d",x.size());
}
```



[神奇的口袋](https://www.nowcoder.com/practice/9aaea0b82623466a8b29a9f1a00b5d35?tpId=40&tqId=21390&tPage=3&rp=3&ru=/ta/kaoyan&qru=/ta/kaoyan/question-ranking)

```c++
#include<bits/stdc++.h>
using namespace std;

int a[30], n, m=0;

void dfs(int x, int step){
    if(x>40) return;
    if(x==40) m++;
    for(int i=step;i<n;i++)
        dfs(x+a[i], i+1);
}

int main(){
    cin>>n;
    for(int i=0;i<n;i++)
        cin>>a[i];
    dfs(0, 0);
    cout<<m<<endl;
}

```

[八皇后](https://www.nowcoder.com/practice/fbf428ecb0574236a2a0295e1fa854cb?tpId=40&tqId=21417&tPage=5&rp=5&ru=/ta/kaoyan&qru=/ta/kaoyan/question-ranking)

```c++
#include<bits/stdc++.h>
using namespace std;

int q[10];
vector<int> ans;

void dfs(int x){
    if(x==8){
        int seq=0;
        for(int i=1;i<=8;i++)
            seq=seq*10+q[i];
        ans.push_back(seq);
    }
    x++;
    for(int i=1;i<=8;i++){
        q[x]=i;
        bool valid=true;
        for(int j=1;j<x;j++){
            if(q[x]==q[j] || abs(x-j)==abs(q[x]-q[j]))
                valid=false;
        }
        if(valid) dfs(x);
    }
}

int main(){
    int b;
    dfs(0);
    while(cin>>b)
        cout<<ans[b-1]<<endl;
}

```

#### 二分搜索



#### 暴力枚举

[Smallest Difference](http://poj.org/problem?id=2718)

```c++
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
using namespace std;

int main(){
    int T,a[15],n;
    char b[20];
    cin>>T;
    getchar();
    while(T--){
        gets(b);
        n=0;
        for(int i=0;i<strlen(b);i++)
            if(b[i]>='0' && b[i]<='9')
                a[n++]=b[i]-'0';

        int MIN=987654321;
        do{
            // 除了数字0外，其他数不能以0开头
            if((a[0]==0 || a[n/2]==0) && n>2)
                continue;
            int x=0, y=0;
            // 两个数位数相近，差才最小
            for(int i=0;i<n/2;i++)
                x=x*10+a[i];
            for(int i=n/2;i<n;i++)
                y=y*10+a[i];
            MIN=min(MIN, abs(x-y));
        }while(next_permutation(a, a+n));
        cout<<MIN<<endl;
    }
}
```

[Backward Digit Sums](http://poj.org/problem?id=3187)

```c++
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
using namespace std;

int c(int n, int k){
	int res = 1;
	for(int i=0;i<k;i++)
        res=res*(n-i)/(i+1);
	return res;
}

int main(){
    int n, m;
    cin>>n>>m;
    int sum=0, a[15];
    for(int i=0;i<10;i++)
        a[i]=i+1;
    do{
        sum=0;
        for(int i=0;i<n;i++)
            // 每个数的系数是组合数（杨辉三角）
            sum+=a[i]*c(n-1,i);
        if(sum==m) break;
    }while(next_permutation(a, a+n));
    for(int i=0;i<n;i++)
        cout<<a[i]<<' ';
    cout<<endl;
}
```

### DP

[整数拆分](https://www.nowcoder.com/practice/376537f4609a49d296901db5139639ec?tpId=40&tqId=21339&tPage=1&rp=1&ru=/ta/kaoyan&qru=/ta/kaoyan/question-ranking)

```c++
#include<bits/stdc++.h>
using namespace std;

const int maxn=1000000+5;
int n, m[maxn];

int main(){
    while(cin>>n){
        m[0]=1;
        for(int i=1;i<=n;i++){
            if(i%2==1) m[i]=m[i-1]%1000000000;
            else m[i]=(m[i-1]+m[i/2])%1000000000;
        }
        cout<<m[n]<<endl;
    }
}
```



### 图论



### 贪心

[Cleaning Shifts](http://poj.org/problem?id=2376)

```c++
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
using namespace std;

const int maxn=25000+5;
int n, t;
struct cow{int s, e;};
cow c[maxn];

bool cmp(cow c1, cow c2){
    if(c1.s==c2.s)
        return c1.e<c2.e;
    return c1.s<c2.s;
}

int main(){
    scanf("%d%d", &n, &t);
    for(int i=0;i<n;i++)
        scanf("%d%d", &c[i].s, &c[i].e);
    sort(c, c+n, cmp);
    int ans=0;
    for(int i=1,j=0;i<=t;){
        int maxi=-1, end=-1;
        // 每次选最长的区间
        for(;j<n;j++){
            if(c[j].s>i) break;
            if(c[j].e>=i && c[j].e-i>maxi){
                maxi=c[j].e-i;
                end=c[j].e;
            }
        }
        if(maxi==-1) {ans=-1; break;}
        i=end+1;
        ans++;
    }
    cout<<ans<<endl;
}
```

[Radar Installation](http://poj.org/problem?id=1328)

思路：[https://blog.csdn.net/ac_hell/article/details/51250550](https://blog.csdn.net/ac_hell/article/details/51250550)

```c++
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
#include<cmath>
using namespace std;

const int maxn=1000+5;
int n, d, T;
struct node{int x, y;};
node c[maxn];

bool cmp(node c1, node c2){
    if(c1.x==c2.x)
        return c1.y<c2.y;
    return c1.x<c2.x;
}

int main(){
    T=0;
    while(cin>>n>>d){
        T++;
        if(n==0) break;
        bool flag=false;
        for(int i=0;i<n;i++){
            cin>>c[i].x>>c[i].y;
            if(c[i].y>d) flag=true;
        }
        if(flag){
            cout<<"Case "<<T<<": -1"<<endl;
            continue;
        }
        sort(c, c+n, cmp);
        int ans=0;
        for(int i=0;i<n;){
            double l, r, xx;
            xx=sqrt(d*d-c[i].y*c[i].y);
            l=c[i].x*1.0-xx;
            r=c[i].x*1.0+xx;
            for(int j=i+1;j<n;j++){
                double l1, r1;
                xx=sqrt(d*d-c[j].y*c[j].y);
                l1=c[j].x*1.0-xx;
                r1=c[j].x*1.0+xx;
                if(l1>r) break;
                l=max(l, l1);
                r=min(r, r1);
                i=j;
            }
            i++;
            ans++;
        }
        cout<<"Case "<<T<<": "<<ans<<endl;
    }
}
```



[代理服务器](https://www.nowcoder.com/practice/1284469ee94a4762848816a42281a9e0?tpId=40&tqId=21335&tPage=1&rp=1&ru=/ta/kaoyan&qru=/ta/kaoyan/question-ranking)

```c++
#include<bits/stdc++.h>
using namespace std;

int main(){
    string a[1005], b[5005];
    int n, m;
    cin>>n;
    for(int i=0;i<n;i++) cin>>a[i];
    cin>>m;
    for(int i=0;i<m;i++) cin>>b[i];
    
    int cnt=-1;
    // 每次选能用次数最多的
    for(int i=0;i<m;){
        int max=0, id=-1;
        for(int j=0;j<n;j++){
            int k;
            for(k=i;k<m;k++)
                if(a[j]==b[k]) break;
            if(k>max) {max=k; id=j;}
        }
        if(id==-1){cnt=-1; break;}
        i=max;
        cnt++;
    }
    cout<<cnt<<endl;
}
```



### 数学

#### gcd && lcm

```c++
int gcd(int a, int b) {
    int r;
    while(b>0) {r=a%b; a=b; b=r;}
    return a;
}

int gcd_recursive(int a, int b){
    return b>0 ? gcd(b, a%b) : a;
}

int lcm(int a, int b){
    return a/gcd(a,b)*b;
}

```

#### exgcd

```c++
int extgcd(int a, int b, int& x, int& y)
{
    int d = a;
    if(b != 0){
        d = extgcd(b, a % b, y, x);
        y -= (a / b) * x;
    } else {
        x = 1;
        y = 0;
    }
    return d;
}

// 乘法逆元
int mod_inverse(int a, int m)
{
    int x, y;
    extgcd(a, m, x, y);
    return (m + x % m) % m;
}
```

#### 组合数

```c++
int c(int n, int k){
	int res = 1;
	for(int i=0;i<k;i++)
        res=res*(n-i)/(i+1);
	return res;
}
```

#### 快速幂

```c++
int fast_pow(int a, int b){
    int ans=1,base=a;
    while(b!=0){
        if(b&1!=0) ans*=base;
        base*=base;
        b>>=1;
    }
    return ans;
}
```

#### Miller Rabbin

```c++
LL modular_multi(LL x, LL y, LL mo){  
    LL t;  
    x%=mo;  
    for(t=0;y;x=(x<<1)%mo,y>>=1)  
        if (y&1)  
            t=(t+x)%mo;  
    return t;  
}  

LL modular_exp(LL num,LL t,LL mo){  
    LL ret=1,temp=num%mo;  
    for(;t;t>>=1,temp=modular_multi(temp,temp,mo))  
        if (t&1)  
            ret=modular_multi(ret,temp,mo);  
    return ret;
}  

bool miller_rabbin(LL n){  
    if (n==2)return true;  
    if (n<2||!(n&1))return false;  
    int t=0;  
    LL a,x,y,u=n-1;  
    while((u&1)==0) t++,u>>=1;
    for(int i=0;i<S;i++){  
        a=rand()%(n-1)+1;  
        x=modular_exp(a,u,n);  
        for(int j=0;j<t;j++){  
            y=modular_multi(x,x,n);  
            if (y==1&&x!=1&&x!=n-1)  
                return false;  
        ///其中用到定理，如果对模n存在1的非平凡平方根，则n是合数。  
        ///如果一个数x满足方程x^2≡1 (mod n),但x不等于对模n来说1的两个‘平凡’平方根：1或-1，则x是对模n来说1的非平凡平方根  
            x=y;  
        }
        if (x!=1)///根据费马小定理,若n是素数，有a^(n-1)≡1(mod n).因此n不可能是素数  
        return false;
    }
    return true;
}

```



[质因数的个数](https://www.nowcoder.com/practice/20426b85f7fc4ba8b0844cc04807fbd9?tpId=40&tqId=21338&tPage=1&rp=1&ru=/ta/kaoyan&qru=/ta/kaoyan/question-ranking)

```c++
#include<bits/stdc++.h>
using namespace std;

int main(){
    int n;
    while(cin>>n){
        int ans=0, i=2;
        double s=sqrt(n);
        while(n>1){
            // 不用筛质数！
            if(n%i==0){
                n/=i;
                ans++;
            }else i++;
            if(i>s) break; 
        }
        if(n>1) ans++;
        cout<<ans<<endl;
    }
}
```

## 数据结构

### 二叉树

[二叉树遍历](https://www.nowcoder.com/practice/4b91205483694f449f94c179883c1fef?tpId=40&tqId=21342&tPage=1&rp=1&ru=/ta/kaoyan&qru=/ta/kaoyan/question-ranking)

```c++
#include<bits/stdc++.h>
using namespace std;

string p;
int i=0;

struct node{
    char v;
    node* l;
    node* r;
};

node* build(){
    char c=p[i++];
    if(c=='#') return NULL;
    node* r=new node;
    r->v=c;
    r->l=build();
    r->r=build();
    return r;
}

void x(node* r){
    if(r==NULL) return;
    x(r->l);
    cout<<r->v<<' ';
    x(r->r);
}

void del(node* r){
    if(r==NULL) return;
    del(r->l);
    del(r->r);
    delete r;
}

int main(){
    while(cin>>p){
        i=0;
        node* r = build();
        x(r);
        cout<<endl;
        del(r);
    }
}
```

